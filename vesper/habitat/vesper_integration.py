"""
VESPER Integration Module for Habitat ObjectNav.

This module integrates the full VESPER smart home simulation with
Habitat 3D navigation, providing:
- IoT device overlay and state management
- Humanoid avatar control
- Task generation via LLM
- Event coordination between navigation and smart home
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from vesper.agents.llm_client import LLMClient

logger = logging.getLogger(__name__)


@dataclass
class VesperConfig:
    """Configuration for VESPER integration."""
    enable_iot: bool = True
    enable_humanoid: bool = True
    enable_llm: bool = True
    auto_device_placement: bool = True
    overlay_opacity: float = 0.8
    llm_endpoint: str = "http://localhost:1234/v1/chat/completions"


@dataclass
class NavigationTask:
    """A navigation task generated by LLM or user."""
    task_id: str
    description: str
    target_object: Optional[str] = None
    target_room: Optional[str] = None
    target_device: Optional[str] = None
    position: Optional[Tuple[float, float, float]] = None
    completed: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "description": self.description,
            "target_object": self.target_object,
            "target_room": self.target_room,
            "target_device": self.target_device,
            "position": self.position,
            "completed": self.completed,
        }


class VesperIntegration:
    """
    Main integration class for VESPER + Habitat.
    
    Coordinates between:
    - Habitat navigation (ObjectNav)
    - IoT device management with real MQTT communication
    - Humanoid avatar
    - LLM task generation
    """
    
    def __init__(
        self,
        config: Optional[VesperConfig] = None,
    ):
        self.config = config or VesperConfig()
        
        # Components (initialized lazily)
        self._iot_manager = None
        self._iot_renderer = None
        self._iot_bridge = None  # Real MQTT-based IoT communication
        self._config_menu = None  # Config menu for adding devices/rules
        self._humanoid = None
        self._humanoid_renderer = None
        self._llm_client = None
        
        # Current scene info
        self.scene_id: Optional[str] = None
        self.rooms: List[str] = []
        
        # Task queue
        self.tasks: List[NavigationTask] = []
        self.current_task: Optional[NavigationTask] = None
        self._task_counter = 0
        
        # Stats
        self._devices_interacted = 0
        self._tasks_completed = 0
    
    def init_iot(
        self,
        rooms: List[str],
        room_positions: Optional[Dict[str, Tuple[float, float, float]]] = None,
    ) -> bool:
        """
        Initialize IoT device system with MQTT communication.
        
        Args:
            rooms: List of room names in the scene
            room_positions: Optional dict mapping room names to positions
            
        Returns:
            True if initialized successfully
        """
        if not self.config.enable_iot:
            return False
        
        try:
            # Initialize the IoT overlay manager for UI
            from vesper.habitat.iot_overlay import IoTDeviceManager, IoTOverlayRenderer
            
            self._iot_manager = IoTDeviceManager()
            self._iot_manager.setup_devices_for_rooms(rooms)
            
            # Set room positions if available
            if room_positions:
                self._iot_manager.room_positions = room_positions
            
            self._iot_renderer = IoTOverlayRenderer(self._iot_manager)
            
            # Initialize the IoT bridge with real MQTT communication
            from vesper.habitat.iot_bridge import IoTBridge
            
            self._iot_bridge = IoTBridge()
            self._iot_bridge.setup_rooms(rooms)
            
            # Set room positions for motion detection
            if room_positions:
                self._iot_bridge.room_positions = room_positions
            
            # Initialize config menu
            from vesper.habitat.iot_config_menu import IoTConfigMenu
            self._config_menu = IoTConfigMenu(self._iot_bridge, rooms)
            
            self.rooms = rooms
            logger.info(f"IoT initialized with {len(rooms)} rooms and MQTT bridge")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize IoT: {e}")
            return False
    
    def init_humanoid(
        self,
        sim: Any = None,
        initial_position: Optional[Tuple[float, float, float]] = None,
    ) -> bool:
        """
        Initialize humanoid avatar.
        
        Args:
            sim: Habitat simulator instance
            initial_position: Starting position
            
        Returns:
            True if initialized successfully
        """
        if not self.config.enable_humanoid:
            return False
        
        try:
            from vesper.habitat.humanoid import HumanoidController, HumanoidRenderer
            
            self._humanoid = HumanoidController()
            
            if sim:
                self._humanoid.attach_to_sim(sim, initial_position)
            elif initial_position:
                self._humanoid.pose.position = initial_position
            
            self._humanoid_renderer = HumanoidRenderer(self._humanoid)
            
            logger.info("Humanoid controller initialized")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize humanoid: {e}")
            return False
    
    def init_llm(
        self,
        endpoint: Optional[str] = None,
    ) -> bool:
        """
        Initialize LLM client for task generation.
        
        Args:
            endpoint: LLM API endpoint
            
        Returns:
            True if initialized successfully
        """
        if not self.config.enable_llm:
            return False
        
        try:
            from vesper.agents.llm_client import LLMClient, LLMConfig
            
            config = LLMConfig(
                base_url=endpoint or self.config.llm_endpoint,
            )
            self._llm_client = LLMClient(config)
            
            logger.info("LLM client initialized")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize LLM: {e}")
            return False
    
    def set_scene(
        self,
        scene_id: str,
        rooms: List[str],
        room_positions: Optional[Dict[str, Tuple[float, float, float]]] = None,
    ):
        """
        Set the current scene context.
        
        Args:
            scene_id: Scene identifier
            rooms: List of room names
            room_positions: Optional mapping of room names to positions
        """
        self.scene_id = scene_id
        self.rooms = rooms
        
        # Update IoT if initialized
        if self._iot_manager:
            self._iot_manager.setup_devices_for_rooms(rooms)
            if room_positions:
                self._iot_manager.room_positions = room_positions
    
    def create_task(
        self,
        description: str,
        target_room: Optional[str] = None,
        target_device: Optional[str] = None,
        target_object: Optional[str] = None,
    ) -> NavigationTask:
        """
        Create a navigation task.
        
        Args:
            description: Task description
            target_room: Target room name
            target_device: Target device ID
            target_object: Target object category
            
        Returns:
            Created NavigationTask
        """
        self._task_counter += 1
        task = NavigationTask(
            task_id=f"task_{self._task_counter:03d}",
            description=description,
            target_room=target_room,
            target_device=target_device,
            target_object=target_object,
        )
        
        self.tasks.append(task)
        return task
    
    def generate_task_from_llm(
        self,
        context: Optional[str] = None,
    ) -> Optional[NavigationTask]:
        """
        Generate a task using the LLM.
        
        Args:
            context: Optional additional context
            
        Returns:
            Generated task or None
        """
        if not self._llm_client:
            logger.warning("LLM not initialized")
            return None
        
        # Build prompt
        room_devices = {}
        if self._iot_manager:
            room_devices = self._iot_manager.get_room_devices_summary()
        
        prompt = f"""You are a smart home task generator. Generate a navigation task for an indoor robot.

Scene: {self.scene_id or "unknown"}
Rooms: {', '.join(self.rooms[:10])}

Devices per room:
"""
        for room, devices in list(room_devices.items())[:5]:
            prompt += f"- {room}: {', '.join(devices)}\n"
        
        prompt += """
Generate ONE simple task. Format:
ACTION: [what to do]
ROOM: [target room]
DEVICE: [target device if any]

Example: 
ACTION: Go to the living room and check if the light is on
ROOM: living room
DEVICE: overhead light"""
        
        if context:
            prompt += f"\n\nContext: {context}"
        
        try:
            from vesper.agents.llm_client import LLMMessage
            
            response = self._llm_client.chat([
                LLMMessage(role="user", content=prompt)
            ])
            
            if response and response.content:
                # Parse response
                task_text = response.content
                room = self._extract_field(task_text, "ROOM")
                device = self._extract_field(task_text, "DEVICE")
                action = self._extract_field(task_text, "ACTION")
                
                if action:
                    return self.create_task(
                        description=action,
                        target_room=room,
                        target_device=device,
                    )
        except Exception as e:
            logger.error(f"LLM task generation failed: {e}")
        
        return None
    
    def _extract_field(self, text: str, field: str) -> Optional[str]:
        """Extract a field from LLM response."""
        for line in text.split("\n"):
            if line.strip().upper().startswith(f"{field}:"):
                return line.split(":", 1)[1].strip()
        return None
    
    def start_task(self, task: NavigationTask):
        """
        Start executing a task.
        
        Args:
            task: Task to start
        """
        self.current_task = task
        logger.info(f"Started task: {task.description}")
    
    def complete_current_task(self):
        """Mark current task as completed."""
        if self.current_task:
            self.current_task.completed = True
            self._tasks_completed += 1
            logger.info(f"Completed task: {self.current_task.description}")
            self.current_task = None
    
    def update_agent_position(
        self,
        agent_position: Tuple[float, float, float],
    ) -> List[Dict[str, Any]]:
        """
        Update agent position and trigger IoT events (motion sensors, etc.).
        
        Args:
            agent_position: Agent's current (x, y, z) position
            
        Returns:
            List of triggered events (motion detected, automations, etc.)
        """
        events = []
        
        if self._iot_bridge:
            # This triggers motion sensors and automation rules
            events = self._iot_bridge.update_agent_position(agent_position)
            
            # Sync device states with the overlay manager for UI display
            if events and self._iot_manager:
                for event in events:
                    if event.get("event_type") == "motion_detected":
                        room = event.get("room")
                        # Update the overlay device state
                        device_id = f"{room}_motion_sensor"
                        if device_id in self._iot_manager.devices:
                            self._iot_manager.devices[device_id].state = "triggered"
        
        return events
    
    def update_humanoid(
        self,
        agent_position: Tuple[float, float, float],
        agent_rotation: Tuple[float, float, float, float],
        action: Optional[str] = None,
    ):
        """
        Update humanoid position and state.
        
        Args:
            agent_position: Agent's current position
            agent_rotation: Agent's rotation quaternion
            action: Current action being executed
        """
        if self._humanoid:
            self._humanoid.sync_with_agent(agent_position, agent_rotation)
            self._humanoid.update(action)
    
    def interact_with_device(self, device_id: str) -> Optional[Dict[str, Any]]:
        """
        Interact with a device via IoT bridge.
        
        Args:
            device_id: Device ID to interact with
            
        Returns:
            Device info dict if found
        """
        # Use IoT bridge for real MQTT communication
        if self._iot_bridge:
            new_state = self._iot_bridge.toggle_device(device_id)
            if new_state:
                self._devices_interacted += 1
                # Sync with overlay
                if self._iot_manager and device_id in self._iot_manager.devices:
                    self._iot_manager.devices[device_id].state = new_state
                return {
                    "device_id": device_id,
                    "new_state": new_state,
                }
        
        # Fallback to overlay manager
        if not self._iot_manager:
            return None
        
        device = self._iot_manager.devices.get(device_id)
        if device:
            # Toggle state
            old_state = device.state
            device.state = "off" if device.state == "on" else "on"
            self._devices_interacted += 1
            
            logger.info(f"Device {device_id} toggled: {old_state} -> {device.state}")
            return {
                "device_id": device_id,
                "type": device.device_type,
                "room": device.room,
                "old_state": old_state,
                "new_state": device.state,
            }
        
        return None
    
    def render(
        self,
        surface,
        camera_matrix: Optional[Any] = None,
        render_iot: bool = True,
        render_humanoid: bool = True,
    ):
        """
        Render VESPER overlays.
        
        Args:
            surface: Pygame surface
            camera_matrix: Camera projection matrix for 3D overlay
            render_iot: Whether to render IoT devices
            render_humanoid: Whether to render humanoid status
        """
        if render_iot and self._iot_renderer:
            self._iot_renderer.render(
                surface,
                camera_matrix=camera_matrix,
            )
        
        if render_humanoid and self._humanoid_renderer:
            self._humanoid_renderer.render_status(surface)
    
    @property
    def iot_manager(self):
        """Get IoT device manager."""
        return self._iot_manager
    
    @property
    def iot_renderer(self):
        """Get IoT overlay renderer."""
        return self._iot_renderer
    
    @property
    def iot_bridge(self):
        """Get IoT bridge for MQTT communication."""
        return self._iot_bridge
    
    @property
    def humanoid(self):
        """Get humanoid controller."""
        return self._humanoid
    
    @property
    def humanoid_renderer(self):
        """Get humanoid renderer."""
        return self._humanoid_renderer
    
    @property
    def llm(self):
        """Get LLM client."""
        return self._llm_client
    
    @property
    def config_menu(self):
        """Get IoT config menu."""
        return self._config_menu
    
    def get_recent_events(self, count: int = 10) -> List[Dict[str, Any]]:
        """Get recent IoT events."""
        if self._iot_bridge:
            return self._iot_bridge.get_recent_events(count)
        return []
    
    def get_automation_rules(self) -> List[Dict[str, Any]]:
        """Get automation rules."""
        if self._iot_bridge:
            return [
                {
                    "name": rule.name,
                    "trigger": rule.trigger_event,
                    "trigger_room": rule.trigger_room,
                    "action": rule.action,
                    "target": rule.target_device_type,
                    "enabled": rule.enabled,
                }
                for rule in self._iot_bridge.automation_rules
            ]
        return []
    
    @property
    def stats(self) -> Dict[str, Any]:
        """Get integration stats."""
        base_stats = {
            "scene_id": self.scene_id,
            "num_rooms": len(self.rooms),
            "num_devices": len(self._iot_manager.devices) if self._iot_manager else 0,
            "tasks_created": self._task_counter,
            "tasks_completed": self._tasks_completed,
            "devices_interacted": self._devices_interacted,
        }
        
        # Add IoT bridge stats
        if self._iot_bridge:
            bridge_stats = self._iot_bridge.stats
            base_stats.update({
                "motion_events": bridge_stats.get("motion_events", 0),
                "automation_triggers": bridge_stats.get("automation_triggers", 0),
                "current_room": bridge_stats.get("current_room"),
                "lights_on": bridge_stats.get("lights_on", 0),
            })
        
        return base_stats


def create_vesper_integration(
    scene_id: str,
    rooms: List[str],
    config: Optional[VesperConfig] = None,
    sim: Any = None,
    initial_position: Optional[Tuple[float, float, float]] = None,
    llm_endpoint: Optional[str] = None,
) -> VesperIntegration:
    """
    Factory function to create and initialize VESPER integration.
    
    Args:
        scene_id: Scene identifier
        rooms: List of room names
        config: Optional configuration
        sim: Habitat simulator instance
        initial_position: Agent's initial position
        llm_endpoint: LLM API endpoint
        
    Returns:
        Initialized VesperIntegration instance
    """
    integration = VesperIntegration(config)
    integration.scene_id = scene_id
    
    # Initialize components
    integration.init_iot(rooms)
    integration.init_humanoid(sim, initial_position)
    
    if llm_endpoint:
        integration.init_llm(llm_endpoint)
    
    logger.info(f"VESPER integration created for {scene_id}")
    return integration
